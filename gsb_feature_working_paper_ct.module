<?php
/**
 * @file
 * Code for the GSB Feature Working Paper Content Type feature.
 */

include_once 'gsb_feature_working_paper_ct.features.inc';

/**
 * Implements hook_menu().
 */
function gsb_feature_working_paper_ct_menu() {
  $items = array();  
  $items['admin/config/gsb/working-paper-refresh-db-email/settings'] = array(
    'title' => 'Working Paper Refresh DB Email Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('gsb_feature_working_paper_ct_refresh_db_email_settings_form'),
    'access arguments' => array('administer working paper refresh db email'),
    'file' => 'gsb_feature_working_paper_ct.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function gsb_feature_working_paper_ct_permission() {
  return array(
    'administer working paper refresh db email' => array(
      'title' => t('Administer Working Paper Refresh DB Email Settings'),
    ),
  );
}

/**
 * Implements hook_token_info().
 */
function gsb_feature_working_paper_ct_token_info() {
  $types['refresh_databases'] = array(
    'name' => t("Refresh Databases Tokens"),
    'description' => t("Tokens from the refresh database email."),
  );  
  $tokens = array();
  $tokens['deletes'] = array(
    'name' => t('Refresh Databases that have been deleted'),
    'description' => t('Get the names of the deleted refresh databases, if any.'),
  );
  $tokens['adds'] = array(
    'name' => t('Refresh Databases that have been added'),
    'description' => t('Get the names of the added refresh databases, if any.'),
  );  
  $tokens['file_url'] = array(
    'name' => t('File url associated with the working paper'),
    'description' => t('Get the file url associated with the working paper.'),
  );
  return array(
    'types' => $types,
    'tokens' => array(
      'refresh_databases' => $tokens,
    ),
  );  
}

/**
 * Implements hook_tokens().
 */
function gsb_feature_working_paper_ct_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'refresh_databases') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'deletes':
          $deletes = $data['refresh_databases']['deletes'];
          if (empty($deletes)) {
            $deletes = '(no changes)';
          }
          $replacements[$original] = $deletes; 
          break;
        case 'adds':
          $adds = $data['refresh_databases']['adds'];
          if (empty($adds)) {
            $adds = '(no changes)';
          }
          $replacements[$original] = $adds;
          break;
        case 'file_url':
          $file_url = '';
          if (!empty($data['refresh_databases']['file_url'])) {
            $file_url = $data['refresh_databases']['file_url'];
          }
          $replacements[$original] = $file_url;
          break;
      }
    }
  }
  return $replacements;
}

/**
 * Implements hook_node_insert().
 */
function gsb_feature_working_paper_ct_node_insert($node) {
  _gsb_feature_working_paper_ct_sendResearchDatabasesEmail($node);
}

/**
 * Implements hook_node_update().
 */
function gsb_feature_working_paper_ct_node_update($node) {
  _gsb_feature_working_paper_ct_sendResearchDatabasesEmail($node);
}

/**
 * Send Research Databases email notification
 */
function _gsb_feature_working_paper_ct_sendResearchDatabasesEmail($node) {

  global $user;

  $language = $node->language;

  // get current list of research databases from the original node
  $currrent_research_dbs = array();
  if (!empty($node->original)) {
    $currrent_research_dbs = _gsb_feature_working_paper_ct_getResearchDatabases($node->original);
  }

  // get new list of research databases from insert/update node
  $new_research_dbs = _gsb_feature_working_paper_ct_getResearchDatabases($node);

  // get list of research databases deleted and added
  list($deletes, $adds) = _gsb_feature_working_paper_ct_key_deletes_adds($currrent_research_dbs, $new_research_dbs);

  // get term names for deleted and added research databases
  $delete_names = _gsb_feature_working_paper_ct_getTermNames($deletes);
  $add_names = _gsb_feature_working_paper_ct_getTermNames($adds);

  // if there haven't been any changes in the refresh database settings, 
  // then no need to send an email
  if (empty($delete_names) && empty($add_names)) {
    return;
  }  

  // get the setting for contact mail
  $contact_email = variable_get('gsb_feature_working_paper_ct_refresh_db_contact_email', t(''));

  // get the setting for email body - which will contain tokens
  $email_body = variable_get('gsb_feature_working_paper_ct_refresh_db_email_body', t(''));

  // get the file url
  $file_url = '';
  if (!empty($node->field_file_single_public[$language])) {
    $fid = $node->field_file_single_public[$language][0]['fid'];
    $file_path = file_load($fid)->uri;
    $file_url = file_create_url($file_path);
  }

  // replace the tokens in the email body
  $email_body = token_replace(
    $email_body,
    array(
      'node' => $node,
      'refresh_databases' => array(
        'deletes' => implode(",", $delete_names),
        'adds' => implode(",", $add_names),
        'file_url' => $file_url,
      )
    )
  );

  // email the notice of delete and adds to contact email address

  $params = array(
    'body' => array($email_body),
    'subject' => 'Working Paper Updated',
  );

  $email_from = 'admin@stanford.edu';
  $message = drupal_mail(
    'gsb_feature_working_paper_ct',
    'update_working_paper',
    $contact_email,
    $language,
    $params,
    $email_from,
    TRUE
  );

}

/**
 * Implements hook_mail().
 */
function gsb_feature_working_paper_ct_mail($key, &$message, $params) {
  $headers = array(
    'MIME-Version' => '1.0',
    'Content-Type' => 'text/html; charset=UTF-8;',
    'Content-Transfer-Encoding' => '8Bit',
    'X-Mailer' => 'Drupal'
  );
  foreach ($headers as $key => $value) {
    $message['headers'][$key] = $value;
  }
  $message['subject'] = $params['subject'];
  $message['body'] = $params['body'];
}

/**
 * Returns a list of term names for a given list of tids
 */
function _gsb_feature_working_paper_ct_getTermNames($tids) {
  $names = array();
  foreach ($tids as $key) {
    $taxonomy = taxonomy_term_load($key);
    $names[] = $taxonomy->name;
  }
  return $names;
}

/**
 * Finds the deletes and adds between old and new arrays
 */
function _gsb_feature_working_paper_ct_key_deletes_adds($old, $new) {
  $intersect = array_intersect_key($old,$new);
  foreach ($intersect as $key) {
    unset($old[$key]);
  }
  $deletes = $old;
  foreach ($intersect as $key) {
    unset($new[$key]);
  }
  $adds = $new;
  return array($deletes, $adds);
}

/**
 * Gets the list of Research Databases set on the node.
 */
function _gsb_feature_working_paper_ct_getResearchDatabases($node) {
  $language = $node->language;
  $research_db_list = array();
  if (isset($node->field_research_databases[$language])) {
    foreach ($node->field_research_databases[$language] as $key => $value) {
      $tid = $node->field_research_databases[$language][$key]['tid'];
      $research_db_list[$tid] = $tid;
    }
  }
  return $research_db_list;
}

/**
 * Implements hook_form_FORM_ID_alter() for working paper node edit form.
 */
function gsb_feature_working_paper_ct_form_working_paper_node_form_alter(&$form, &$form_state) {

  $language = $form['language']['#value'];

  $form['title']['#prefix'] =
  'For help with adding or editing working papers, <a href="https://remedyweb.stanford.edu/helpsu/gsb" target="_blank">submit a HelpSU ticket</a>.<br><br>';

  $form['title']['#description'] = 'Enter the title of the working paper (in title case). | <strong>Example</strong>: The Timing and Frequency of Corporate Disclosures';

  //$form['field_year_of_publication']['und'][0]['#description'] = 'test';

  $form['field_document_uuid']['#access'] = FALSE;
  $form['field_document_name']['#access'] = FALSE;
  $form['field_paper_copy']['#access'] = FALSE;
  $form['field_product_type']['#access'] = FALSE;
  $form['field_item_id']['#access'] = FALSE;

  // Research databases taxonomy field checkbox alter
  if (empty($form['nid']['#value'])) {
    $research_field = $form['field_research_databases'][$language]['#options'];
    $default_value = array();
    foreach ($research_field as $key => $value) {
      $taxonomy_term = taxonomy_term_load($key);
      if (!empty($taxonomy_term->field_default_checkbox_status[$language][0]['value'])) {
        $default_value[] = $key;
      }
    }
    $form['field_research_databases'][$language]['#default_value'] = $default_value;
  }

}  

/**
 * Sets up a callback function for handling the cmis import
 */
function gsb_feature_working_paper_ct_gsb_cmis_content_type_import_info() {
  return array(
    'working_paper' => array(
      'callback' => 'gsb_feature_working_paper_ct_cmis_import',
    ),
  );
}

/**
 * The callback function for handling the cmis import for
 * the Working Paper content type.
 */
function gsb_feature_working_paper_ct_cmis_import($doc, $uuid) {

  global $user;

  // Check if the Product Type has been set. If not, bail.
  if (empty($doc->properties['gsb:cwoProductType']) || trim($doc->properties['gsb:cwoProductType']) == '') {
    return;
  }

  // Valid Product Types for 'Working Paper' Content type is:
  //   Working Paper
  $product_type = $doc->properties['gsb:cwoProductType'];
  if ($product_type != 'Working Paper') {
    return;
  }

  // Attempt to find a node with the document uuid
  $query = new EntityFieldQuery();
  $query->fieldCondition('field_document_uuid', 'value', $uuid, '=')->range(0, 1);
  $entities = $query->execute();

  if (!empty($entities['node'])) {
    // a node already exists, so load it
    $nids = array_keys($entities['node']);
    $node = node_load(array_shift($nids));
  } else {
    // a node does exist, so create one
    $values = array(
      'type' => 'working_paper',
      'uid' => $user->uid,
      'status' => 1,
      'comment' => 1,
      'promote' => 0,
    );
    $node = entity_create('node', $values);
  }

  // if the node isn't a Working Paper, then bail
  if ($node->type != 'working_paper') {
    return;
  }

  gsb_cmis_log('uuid = '.$uuid, 'success');

  $ewrapper = entity_metadata_wrapper('node', $node);

  gsb_cmis_log('writing document uuid', 'success');

  $ewrapper->field_document_uuid->set($uuid);

  gsb_cmis_log('writing title', 'success');

  if (!empty($doc->properties['cm:title']) && trim($doc->properties['cm:title']) != '') {
    $ewrapper->title->set($doc->properties['cm:title']);
  } else {
    // if title is empty, then try to use document name
    if (!empty($doc->properties['cmis:contentStreamFileName']) && trim($doc->properties['cmis:contentStreamFileName']) != '') {
      $ewrapper->title->set($doc->properties['cmis:contentStreamFileName']);
    } else {
      $ewrapper->title->set('no title');
    }  
  }

  gsb_cmis_log('writing field_document_name', 'success');

  if (!empty($doc->properties['cmis:contentStreamFileName']) && trim($doc->properties['cmis:contentStreamFileName']) != '') {
    gsb_cmis_log('writing field_document_name = '.$doc->properties['cmis:contentStreamFileName'], 'success');
    $ewrapper->field_document_name->set($doc->properties['cmis:contentStreamFileName']);
  } else {
    $ewrapper->field_document_name->set(NULL);
  }  

  gsb_cmis_log('writing field_description', 'success');

  if (!empty($doc->properties['cm:description']) && trim($doc->properties['cm:description']) != '') {
    $ewrapper->field_description->set($doc->properties['cm:description']);
  } else {
    $ewrapper->field_description->set(NULL);
  }

  gsb_cmis_log('writing field_product_type', 'success');

  $ewrapper->field_product_type->set($product_type);

  gsb_cmis_log('writing field_business_insight_topic', 'success');

  if (!empty($doc->properties['gsb:cwoBusinessTopics']) && trim($doc->properties['gsb:cwoBusinessTopics']) != '') {
    $ids = array();
    $bi_topic = $doc->properties['gsb:cwoBusinessTopics'];
    $results = taxonomy_get_term_by_name($bi_topic);
    foreach ($results as $item) {
      if ($item->vocabulary_machine_name == 'business_insight_topic') {
        $ids[] = $item->tid;
      }
    }
    $ewrapper->field_business_insight_topic->set($ids);
  } else {
    $ewrapper->field_business_insight_topic = array();
  }

  gsb_cmis_log('writing field_academic_area_unlimited', 'success');

  if (!empty($doc->properties['gsb:cwoAcademicArea']) && trim($doc->properties['gsb:cwoAcademicArea']) != '') {
    $ids = array();
    $academic_area = $doc->properties['gsb:cwoAcademicArea'];
    $results = taxonomy_get_term_by_name($academic_area);
    foreach ($results as $item) {
      if ($item->vocabulary_machine_name == 'academic_area') {
        $ids[] = $item->tid;
      }
    }
    $ewrapper->field_academic_area_unlimited->set($ids);
  } else {
    $ewrapper->field_academic_area_unlimited = array();
  }

  gsb_cmis_log('writing field_authors', 'success');

  if (!empty($doc->properties['gsb:authorsSunetId']) && trim($doc->properties['gsb:authorsSunetId']) != '') {
    _gsb_feature_working_paper_ct_import_authors($node,$ewrapper,$doc);
  }

  gsb_cmis_log('writing field_paper_copy', 'success');

  if (!empty($doc->properties['gsb:cwoPaperCopy']) && trim($doc->properties['gsb:cwoPaperCopy']) != '') {
    $ewrapper->field_paper_copy->set($doc->properties['gsb:cwoPaperCopy']);
  } else {
    $ewrapper->field_paper_copy->set(NULL);
  }  
  
  gsb_cmis_log('writing field_item_id', 'success');

  if (!empty($doc->properties['gsb:cwoItemId']) && trim($doc->properties['gsb:cwoItemId']) != '') {
    $ewrapper->field_item_id->set($doc->properties['gsb:cwoItemId']);
  } else {
    $ewrapper->field_item_id->set(NULL);
  }  
  
  gsb_cmis_log('writing field_year_of_publication', 'success');

  if (!empty($doc->properties['gsb:cwoPublicationYear']) && trim($doc->properties['gsb:cwoPublicationYear']) != '') {
    $year = $doc->properties['gsb:cwoPublicationYear'];
    gsb_cmis_log('year = '.$year, 'success');
    if (is_numeric($year)) {
      $date = new DateTime($year."-01-01");
      $ewrapper->field_year_of_publication->set($date->getTimestamp());
      $ewrapper->field_month->set(NULL);
    } else {
      $ewrapper->field_year_of_publication = NULL;
    }
  } else {
    $ewrapper->field_year_of_publication = NULL;
  }  
  
  gsb_cmis_log('writing field_tag', 'success');

  $tags = _gsb_feature_working_paper_ct_getTags($uuid);

  if (!empty($tags)) {
    $ids = array();
    $term_list = array();
    _gsb_feature_working_paper_ct_add_tags($tags);
    foreach($tags as $term) {
      $results = taxonomy_get_term_by_name($term);
      $term_list = array_merge($term_list, $results);
    }
    foreach ($term_list as $item) {
      if ($item->vocabulary_machine_name == 'tag') {
        $ids[] = $item->tid;
      }
    }
    $ewrapper->field_tag->set($ids);
  } else {
    $ewrapper->field_tag = array();
  }

  gsb_cmis_log('saving node', 'success');

  $ewrapper->save();
  
}

/**
 * Add the working papers tags from the returned Alfresco data 
 */
function _gsb_feature_working_paper_ct_add_tags($tags) {
  $vocab = taxonomy_vocabulary_machine_name_load('tag');
  $vid = $vocab->vid;
  foreach($tags as $term) {
    $results = taxonomy_get_term_by_name($term);
    if (empty($results)) {
      _gsb_feature_working_paper_ct_add_tag_term($term, $vid);
    } else {
      $found = FALSE; 
      foreach ($results as $item) {
        if ($item->vocabulary_machine_name == 'tag') {
          $found = TRUE;
          break;
        }    
      }
      if (!$found) {
        _gsb_feature_working_paper_ct_add_tag_term($term, $vid);
      }
    }
  }
}

/**
 * Add a tag term 
 */
function _gsb_feature_working_paper_ct_add_tag_term($term, $vid) {
  $new_term = new stdClass();
  $new_term->name = $term;
  $new_term->description = '';
  $new_term->vid = $vid;
  $new_term->parent = null;
  taxonomy_term_save($new_term);
}

/**
 * Get the list of tags from Alfresco
 */
function _gsb_feature_working_paper_ct_getTags($uuid) {

  $tags = array();

  $repo_info = variable_get('cmis_repositories', false);
  if (!$repo_info) {
    return $tags;
  }

  // get the id - striped down to just the number 

  $id = str_replace('urn:uuid:', '', $uuid);

  // put together the url for the alfresco service call - to get 'tags'

  $url = $repo_info['default']['service_url'];
  $url = $url . $id . '/tags';

  // get the user and password

  $user = $repo_info['default']['user'];
  $password = $repo_info['default']['password'];

  // setup the curl options

  $session = curl_init();

  curl_setopt($session, CURLOPT_URL, $url);
  curl_setopt($session, CURLOPT_SSL_VERIFYPEER, FALSE);
  curl_setopt($session, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($session, CURLOPT_FOLLOWLOCATION, 1);
  curl_setopt($session, CURLOPT_COOKIEFILE, "");
  curl_setopt($session, CURLOPT_USERPWD, $user. ":" . $password);
  curl_setopt($session, CURLOPT_HTTPHEADER, array("Content-Type" => ""));
  curl_setopt($session, CURLOPT_CUSTOMREQUEST, "GET");

  // make the return value object

  $retval = new stdClass();
  $retval->url = $url;
  $retval->method = "GET";
  $retval->content_sent = null;
  $retval->content_type_sent = "";

  // make the curl call

  $retval->body = curl_exec($session);

  // set the return values

  $retval->code = curl_getinfo($session, CURLINFO_HTTP_CODE);
  $retval->content_type = curl_getinfo($session, CURLINFO_CONTENT_TYPE);
  $retval->content_length = curl_getinfo($session, CURLINFO_CONTENT_LENGTH_DOWNLOAD);

  // close the curl session

  curl_close($session);

  if ($retval->code == '200') {
    $tags = drupal_json_decode($retval->body);
  }

  return $tags;
}

/**
 * Set the list of tags to Alfresco
 */
function _gsb_feature_working_paper_ct_setTags($uuid, $tags) {

  $repo_info = variable_get('cmis_repositories', false);
  if (!$repo_info) {
    return false;
  }

  // get the id - striped down to just the number 

  $id = str_replace('urn:uuid:', '', $uuid);

  // put together the url for the alfresco service call - to get 'tags'

  $url = $repo_info['default']['service_url'];
  $url = $url . $id . '/tags';

  // get the user and password

  $user = $repo_info['default']['user'];
  $password = $repo_info['default']['password'];

  // setup the curl options

  $session = curl_init();

  curl_setopt($session, CURLOPT_URL, $url);
  curl_setopt($session, CURLOPT_SSL_VERIFYPEER, FALSE);
  curl_setopt($session, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($session, CURLOPT_FOLLOWLOCATION, 1);
  curl_setopt($session, CURLOPT_COOKIEFILE, "");
  curl_setopt($session, CURLOPT_USERPWD, $user. ":" . $password);
  curl_setopt($session, CURLOPT_CUSTOMREQUEST, "POST");

  // pass the tags as data in the header
  $data_string = json_encode($tags);     
                                                                                                                                      
  curl_setopt($session, CURLOPT_POSTFIELDS, $data_string);                                                                                                                                 
  curl_setopt($session, CURLOPT_HTTPHEADER, array(                                                                          
      'Content-Type: application/json',                                                                                
      'Content-Length: ' . strlen($data_string))                                                                       
  );                                                                                                                   

  // make the return value object

  $retval = new stdClass();
  $retval->url = $url;
  $retval->method = "POST";
  $retval->content_sent = null;
  $retval->content_type_sent = "";

  // make the curl call

  $retval->body = curl_exec($session);

  // set the return values

  $retval->code = curl_getinfo($session, CURLINFO_HTTP_CODE);
  $retval->content_type = curl_getinfo($session, CURLINFO_CONTENT_TYPE);
  $retval->content_length = curl_getinfo($session, CURLINFO_CONTENT_LENGTH_DOWNLOAD);

  // close the curl session

  curl_close($session);

  if ($retval->code == '200') {
    $result = drupal_json_decode($retval->body);
  }

  return $result;
  
}

/**
 * Get authors from the Alfresco doc properties
 */
function _gsb_feature_working_paper_ct_import_authors($node,$ewrapper,$doc) {

  // get the list of sunetids from Alfresco's returned data
  $sunet_ids = array_map('trim', explode(',', $doc->properties['gsb:authorsSunetId']));

  // lookup the node ids related to these ids
  $query = db_select('field_data_field_sunetid', 'su');
  $query->fields('su', array('bundle', 'entity_id', 'field_sunetid_value'));
  $query->condition('su.field_sunetid_value',$sunet_ids,'IN');
  $result = $query->execute();

  // keep these node ids in a list
  $entity_ids = array();
  foreach ($result as $record) {
    $entity_ids[$record->entity_id] = $record->entity_id;
  }

  // get the current list of authors saved with the node
  $authors = $ewrapper->field_authors->value();

  // if any of the author ids match one of the sunetid node ids, then
  // we don't need to add it, and can remove it from our list
  foreach($authors as $author) {
    $ewrap_author = entity_metadata_wrapper('field_collection_item', $author);
    $ref = $ewrap_author->field_person_fac_single_ref->value();
    if ($ref) {
      $author_nid = $ref->nid;
      if (!empty($entity_ids[$author_nid])) {
        unset($entity_ids[$author_nid]);
      }
    }
  }

  // check for an 'default/empty' author field collection
  // remove if this is the case, and we have authors to add
  $found_default = FALSE;
  if (count($authors) == 1) {
    if (empty($authors[0]->field_first_name)) {
      if (empty($authors[0]->field_last_name)) {
        if (empty($authors[0]->field_person_fac_single_ref)) {
          $found_default = TRUE;
        }
      }
    }
  }
  if ($found_default && count($entity_ids) > 0) {
    $ewrapper->field_authors->set(NULL);
  }

  // add any new authors that came for the sunetids
  foreach ($entity_ids as $entity_id) {
    _gsb_feature_working_paper_ct_add_author($node, $entity_id);
  }  

}  

/**
 * Add an author entity ref (via field_authors field collection) 
 * to the node's current list
 */
function _gsb_feature_working_paper_ct_add_author($node, $entity_id) {

  $field_collection_item = entity_create('field_collection_item', array('field_name' => 'field_authors'));
  $field_collection_item->setHostEntity('node', $node);

  $field_collection_item->field_person_fac_single_ref = array(
    'und' => array(array('target_id' => $entity_id)),
  );

  $field_collection_item->field_person_fac_or_other = array(
    'und' => array(array('value' => 'UseEntityReference')),
  );

  $field_collection_item->field_first_name = array();
  $field_collection_item->field_last_name = array();

  $field_collection_item->save();

}

